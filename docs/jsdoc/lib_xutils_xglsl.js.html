<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/xutils/xglsl.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/xutils/xglsl.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
import * as THREE from 'three'
import {x} from '../xapp/xworld'
import {ShaderFlag} from '../component/visual'
import * as xutils from './xcommon'
import AssetKeepr from './assetkeepr'

/**
 * Stub for jsdoc, a collection of common methods
 * &lt;b>NOTE: no 'xglsl.' prefix when calling functions.&lt;/b>
 * &lt;br>This class name is all in lower case. X-visual use this convention for a
 * collection of common global methods when using jsdoc generating API doc.
 * @class
 */
function xglsl() { }

const shaderPool = {}

/**
 * @param {int} flag @see ShaderFlag
 * @param {Visual.paras} vparas @see Visual
 * @return {object} {vertexShader, fragmentShader}&lt;br>
 * The shaders for THREE.ShaderMaterial (using variables supported by Three.js)&lt;br>
 * where&lt;br>
 * return.vertextShader {string}&lt;br>
 * return.vertextShader {string}
 * @member xglsl.randomRarticl
 * @function */
export function xvShader(flag, vparas) {
	var s;
    switch (flag &amp; ShaderFlag.mask) {
        case ShaderFlag.randomParticles:
            s = randomParticl(vparas);
			break;
        case ShaderFlag.cubeVoxels:
            s = cubeVoxels(vparas);
			break;
		case ShaderFlag.flameLight:
			s = flameLight(vparas);
			break;
		case ShaderFlag.throbStar:
			s = throbStar(vparas);
			break;
		case ShaderFlag.colorArray:
			// meshColors() is deprecated
			// s = meshColors(vparas);
			s = phongColorMorph(vparas);
			// TODO share shader progam
			// if (shaderPool.phongColorMorph)
			// 	s = shaderPool.phongColorMorph;
			// else {
			// 	s = phongColorMorph(vparas);
			// 	shaderPool.phongColorMorph = s;
			// }
			break;
        case ShaderFlag.testPoints:
        default:
			s = testPnt(vparas || {});// as enum doesn't exists, paras also likely undefined
    }
	if (x.log >= 5)
		console.debug(`[5] flag: ${flag.toString(16)}, paras: `,
			vparas, '\nshaders: ', s);
	return s;
}

/**
 * Merge Visual.paras.uniforms, load texture according to Visual.paras.u_tex.
 * @param {Visual} cmpVisual
 * @param {Obj3} cmpObj3 not used?
 * @return {object} uniforms for THREE.Mesh - properties are in format of name: {value}
 * @member xglsl.formatUniforms
 * @function
 */
export function formatUniforms(cmpVisual, cmpObj3) {
	var uniforms = {};
	if (cmpVisual.paras &amp;&amp; cmpVisual.paras.u_tex) {
		if (cmpVisual.paras.uniforms &amp;&amp; typeof cmpVisual.paras.uniforms.u_tex === 'string') {
			console.warn ( "formatUniforms(): ignoring wrong paras: Visual.paras.uniforms.u_tex = ",
							cmpVisual.paras.uniforms.u_tex );
			delete cmpVisual.paras.uniforms.u_tex;
		}
		uniforms = {
			u_tex: { value: new THREE.TextureLoader().load(`assets/${cmpVisual.paras.u_tex}`) }
		};
	}
	else if (cmpVisual.paras.uniforms &amp;&amp; typeof cmpVisual.paras.uniforms.u_tex === 'string') {
		console.warn ( "formatUniforms(): takeing Visual.paras.uniforms.u_tex as uniform for shader.",
					   "The correct paras for u_tex is Visual.paras.u_tex.",
						cmpVisual.paras.uniforms.u_tex );
		uniforms = {
			u_tex: { value: new THREE.TextureLoader().load(`assets/${cmpVisual.paras.uniforms.u_tex}`) }
		};
		delete cmpVisual.paras.uniforms.u_tex;
	}
	else if ((cmpVisual.shader &amp; ShaderFlag.defaultex) === ShaderFlag.defaultex) {
		uniforms = {
			u_tex: { value: AssetKeepr.defaultex() }
		};
	}

	if (cmpVisual.paras.uniforms)
		Object.assign(uniforms, obj2uniforms(cmpVisual.paras.uniforms));

	return uniforms;
}

/**
 * Convert object into THREE.Mesh.uniforms format (properties are {value} object).&lt;br>
 * x-visual v.s. Three.js material variable name mapping:&lt;pre>
    three.js -&amp;gt; x-visual shader
    opacity - u_alpha
 &lt;/pre>
 * @param {object} properties
 * @param {THREE.Uniforms} uniforms
 * @return {object} uniforms for THREE.Mesh - properties are in format of name: {value}
 * @member xglsl.obj2uniforms
 * @function
 */
export function obj2uniforms(properties, uniforms) {
	var u = {};
	for (var p in properties) {
		if (p === 'opacity')
			u.u_alpha = {value: properties[p]};
		else
			u[p] = {value: properties[p]};
	}
	return Object.assign(uniforms || {}, u);
}

/**
 * Convert script value to THREE.Uniforms format (properties are {value} object).
 * &lt;br>If properties of svals is an array, only it's first value are used as the
 * uniforms value - required by Tween.
 * @param {object} svals script values
 * @param {Obj3} uniforms buffer
 * @return {object} {start: svals_i[0], to: value: svals_i[1]}&lt;br>
 * uniforms for THREE.Mesh - properties are in format of name: {value}
 * @member xglsl.script2uniforms
 * @function
 */
export function script2uniforms(svals, uniforms) {
	var u = {};
	var v = {};
	for (var p in svals) {
		if (Array.isArray(svals[p])) {
			u[p] = {value: svals[p][0]};
			v[p] = {value: svals[p][1]};
		}
		else if (typeof svals[p] === 'number') {
			u[p] = {value: svals[p]};
			v[p] = {value: svals[p]};
		}
		else throw XError(`xglsl.script2uniforms(): can't convert vals to uniforms: svals[${p}]: ${svlas[p]}`);
	}
	uniforms = Object.assign(uniforms || {}, u);
	return {start: uniforms, to: v};
}

/**Get shader for ShaderFlag.randomParticles.
 * If u_morph is animated, must providing uniform vec3 &amp;amp a_target.
 * Used variables: position, color, size.
 * gl_position = mix(pos, taget, morph) + noise * dist;
 * @param {object} paras
 * paras.u_dist {float} in world
 * paras.u_morph {float}
 * paras.a_dest {vec3} in world
 * paras.a_noise {float}
 * paras.size_scale {float}
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.randomRarticl
 * @function */
function randomParticl(paras) {
 return { vertexShader: `
  uniform float u_alpha;
  uniform float u_dist;
  uniform float u_morph;

  attribute vec3 color;
  attribute float size;
  ${paras.a_dest ? 'attribute vec3 a_dest;' : ''}
  ${paras.a_noise ? 'attribute float a_noise;' : ''}

  varying vec3 vColor;
  varying float vAlpha;

  void main() {
    vColor = color;
	vAlpha = u_alpha;
	${!paras.a_dest &amp;&amp; !paras.a_noise ? 'vec3 pos = position * (1.0 + u_morph);' : ''}
	${ paras.a_dest &amp;&amp; !paras.a_noise ? 'vec3 pos = mix(position, a_dest, u_morph) + u_dist * 5.0;' : ''}
	${!paras.a_dest &amp;&amp; paras.a_noise ? 'vec3 pos = position + u_dist * 100 * a_noise;' : ''}
	${ paras.a_dest &amp;&amp; paras.a_noise ? 'vec3 pos = mix(position, a_dest, u_morph) + u_dist * 5.0 * a_noise;' : ''}
    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );

    // gl_PointSize = u_morph * ( 300.0 / -mvPosition.z );
	gl_PointSize = size * ${paras.vert_scale || '10.0'};
    gl_Position = projectionMatrix * mvPosition;
  } `,
 fragmentShader: `
  uniform sampler2D u_tex;
  varying vec3 vColor;
  varying float vAlpha;

  void main() {
    gl_FragColor = vec4( vColor, 1.0 );
    gl_FragColor = gl_FragColor * texture2D( u_tex, gl_PointCoord );
    gl_FragColor.a *= vAlpha;
  } `
 };
}

/**@deprecated this function can be completely covered by cubeVoxelGeom().
 * Create geometry buffer from target mesh.
 * If shader type is randomParticles, the buffer also has attributes color and size.
 * @param {Visual.paras} vparas
 * @param {TREE.Mesh} meshSrc
 * @param {TREE.Mesh} meshTarget
 * @return {THREE.BufferGeometry}
 * @member xglsl.particlesGeom
 * @function
 */
export function particlesGeom (vparas, meshSrc, meshTarget) {
	var sizes = [];
	var colors = [];
	var noise = [];
	// var count = meshSrc.count / meshSrc.itemSize;	// count = length / 3
	var count = meshSrc.count;
	for (var c = 0; c &lt; count; c++) {
		var color = xutils.randomRGB();
		colors.push( color.r, color.g, color.b );
		sizes.push( (Math.random() * 2 - 1 ) );

		if (vparas &amp;&amp; vparas.a_noise)
			noise.push( (Math.random() * vparas.noise - vparas.noise / 2 ) );
	}

	var geometry = new THREE.BufferGeometry();
	geometry.setAttribute( 'position', meshSrc.clone(), 3 );

	geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 )
			.setUsage( THREE.DynamicDrawUsage ) );
	geometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 )
			.setUsage( THREE.DynamicDrawUsage ) );

	if (vparas &amp;&amp; vparas.a_noise)
		geometry.setAttribute( 'a_noise', new THREE.Float32BufferAttribute( noise, 1 )
			.setUsage( THREE.DynamicDrawUsage ) );

	// TODO case: meshsrc.count != meshTarget.count
	if (vparas &amp;&amp; (vparas.dest || vparas.a_dest)) {
		geometry.setAttribute( 'a_dest', meshTarget.clone(), 3 );
	}
	return geometry;
}

/** get shader of gl_point for debugging
 * @param {object} paras paras.vert_scale [optional] number scale of vertices
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.testPnt
 * @function
 */
function testPnt(paras = {}) {
 return { vertexShader: `
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    gl_PointSize = 3.0 * ${paras.vert_scale || '1.0'}; }`,
 fragmentShader: `
  void main() {
    gl_FragColor = vec4( 1., 1., 0., 1. ); }`
 };
}

/**Create vertex &amp; fragment shaders that can morphing between multiple positions.
 * @deprecated
 * @param {object} paras
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.cubeVoxels9
 * @function
 */
function cubeVoxels9(paras) {
 return { vertexShader: `
  uniform float u_alpha;
  uniform vec3 u_sects;
  uniform vec3 u_box0;
  uniform vec3 u_box1; uniform float u_morph1; uniform mat4 u_trans1;
  ${paras.a_dest2 ? 'uniform vec3 u_box2; uniform float u_morph2; uniform mat4 u_trans2' : ''}

  attribute vec3 color;
  attribute float size;
  ${paras.a_noise ? 'attribute float a_noise;' : ''}
  // attribute vec3 ix;	// use position as index

  varying vec3 vColor;
  varying float vAlpha;

  vec4 ix2world(vec3 sects, vec3 box) {
    return modelViewMatrix * vec4(box * sects / u_sects, 1.0);
  }

  void main() {
    vColor = color;
	vAlpha = u_alpha;
	vec4 pos0 = ix2world(position, u_box0);
	vec4 pos1 = ix2world(position, u_box1);
	pos0 = mix(modelViewMatrix * pos0, u_trans1 * pos1, u_morph1);
	// ${paras.a_noise &amp;&amp; !paras.vert_scale ? 'pos0.xyz += a_noise * color' : ''}
	// ${paras.a_noise &amp;&amp;  paras.vert_scale ? 'pos0.xyz += a_noise * color * ' + paras.vert_scale : ''}

	${paras.a_dest2 ? 'pos1 = ix2world(position, a_box2);' : ''}
	${paras.a_dest2 ? 'pos0 = mix(pos0, u_trans2 * pos1, u_morph2);' : ''}

	${paras.a_noise &amp;&amp; !paras.vert_scale ? 'pos0.xyz += a_noise * color' : ''}
	${paras.a_noise &amp;&amp;  paras.vert_scale ? 'pos0.xyz += a_noise * color * ' + paras.vert_scale : ''}

    //vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
	gl_PointSize = size * ${paras.vert_scale || '10.0'};
    gl_Position = projectionMatrix * pos0; //mvPosition;
    // gl_Position = projectionMatrix * vec4(0., 0., 0., 1.);

	gl_PointSize = 100000.0;
  }
  `,

 fragmentShader: `
  uniform sampler2D u_tex;
  varying vec3 vColor;
  varying float vAlpha;

  void main() {
    gl_FragColor = vec4( vColor, 1.0 );
    gl_FragColor = gl_FragColor * texture2D( u_tex, gl_PointCoord );
    gl_FragColor.a *= vAlpha;
  } `
 };
}

/**Create vertex &amp;amp; fragment shaders that can morphing between multiple box positions.
 * @param {object} paras
 * paras.uniforms.u_cubes array of boxes
 * param.uniforms.u_box1, 2, ... vec3 for position index (voxel index, not position)
 * param.uniforms.u_morph, morph animation, 0 - 1
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.cubeVoxels
 * @function
 */
function cubeVoxels(paras) {
	var boxi = ''; // 'uniform vec3 u_box0; uniform float u_morph0;';
	var pos = '';
	for (var i = 0; i &lt; paras.uniforms.u_cubes.length; i++) {
		boxi += `\nuniform vec3 u_box${i}; uniform float u_morph${i};`;
		if (i > 0)
		pos += `pos = mix(pos, ix2model(u_sects, u_box${i}), u_morph${i-1});\n    `
			 + `p_ = mix(p_, next2model(u_sects, u_box${i}), u_morph${i-1});\n    `;
	}
	pos += `pos = mix(pos, ix2model(u_sects, u_box0), u_morph${i-1});\n    `;
		 + `p_ = mix(p_, next2model(u_sects, u_box0), u_morph${i-1});\n    `;

 return { vertexShader: `
  uniform float u_alpha;
  uniform vec3 u_sects;
  //uniform vec3 u_box0; uniform float u_morph0;
  ${boxi}

  attribute vec3 color;

  varying vec3 vColor;
  varying float vAlpha;

  vec4 ix2model(vec3 sects, vec3 box) {
    return vec4((position - sects / 2.) * box / sects, 1.);
  }

  vec3 next2model(vec3 sects, vec3 box) {
    return (position + 1. - sects/ 2.) * box / sects;
  }

  void main() {
	vColor = color;
	vAlpha = u_alpha;

	vec4 pos = ix2model(u_sects, u_box0);
	vec3 p_ = next2model(u_sects, u_box0);	// also morph next grid
	vec3 d0 = p_ - pos.xyz;					// model 0 section length
	// pos = mix(pos, ix2model(u_sects, u_box1), u_morph1);
	${pos}

    gl_Position = projectionMatrix * modelViewMatrix * pos;
	vec4 p1 = projectionMatrix * modelViewMatrix * vec4(p_, 1.);

	gl_PointSize = 3.0 * ${paras.vert_scale !== undefined ? paras.vert_scale : '10.0'};
	// scale point size as the same to section scale
	vec3 d1 = p1.xyz - pos.xyz;
	gl_PointSize *= length(d0) / length(d1);
  }
  `,

 fragmentShader:
 // `void main() { gl_FragColor = vec4(1.0); } `
 `uniform sampler2D u_tex;
  varying vec3 vColor;
  varying float vAlpha;

  void main() {
    gl_FragColor = vec4( vColor, 1.0 );
    gl_FragColor = gl_FragColor * texture2D( u_tex, gl_PointCoord );
    gl_FragColor.a *= vAlpha;
  } `
 }
};

/**Get geometry buffer for cube voxels, with attributes that the shader can work,
 * each vertex has a random color, noise and size.&lt;br>
 * The uniform names are color, size (default by Three.js) and a_noise.
 * @param {object} vparas
 * u_sects: [w, h, d] segements in 3D
 * @return {THREE.BufferGeometry} the geometry buffer.
 * @member xglsl.cubeVoxels
 * @function
 */
export function cubeVoxelGeom(vparas) {
	var whd = vparas.u_sects;
	var ixyz = []; // position, a.k.a vertex index
	var colors = [];
	var sizes = [];
	var noise = [];
	var count = (whd[0] + 1) * (whd[1] + 1) * (whd[2] + 1);
	for (var iw = 0; iw &lt;= whd[0]; iw++)
		for (var ih = 0; ih &lt;= whd[1]; ih++)
			for (var id = 0; id &lt;= whd[2]; id++) {
				ixyz.push(iw, ih, id);
				var color = xutils.randomRGB();
				colors.push( color.r, color.g, color.b );
				sizes.push( (Math.random() * 2 - 1 ) );

				if (vparas.a_noise)
					noise.push( (Math.random() * vparas.noise - vparas.noise / 2 ) );
			}

	var geometry = new THREE.BufferGeometry();
	geometry.setAttribute( 'position', new THREE.Float32BufferAttribute(ixyz, 3) );

	geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 )
			.setUsage( THREE.DynamicDrawUsage ) );
	geometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 )
			.setUsage( THREE.DynamicDrawUsage ) );

	if (vparas.a_noise)
		geometry.setAttribute( 'a_noise', new THREE.Float32BufferAttribute( noise, 1 )
				.setUsage( THREE.DynamicDrawUsage ) );

	return geometry;
}

/**Example:
 * See docs/design memoe/shader samples
 *
 * @param {object} vparas visual paras, same as Visual.paras
 * @member xglsl.flameLight
 * @function
 */
function flameLight(vparas) {
	throw XError("TODO");
}

/**Example:
 * See docs/design memoe/shader samples
 *
 * @param {object} paras
 * paras.vert_scale: point scale
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.flameLight
 * @function
 */
function throbStar(paras = {}) {
 return { vertexShader: `
  uniform vec2 fragSize;
  varying vec2 size;

  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    gl_PointSize = 3.0 * ${paras.vert_scale || '10.'};

    if (fragSize.x == 0. &amp;&amp; fragSize.y == 0.)
      size = vec2(gl_PointSize);
 }`,
 fragmentShader: `
  uniform float iTime;

  varying vec2 size;

  float noise(vec3 p) {
    vec3 i = floor(p);
    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);
    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;
    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);
    a.xy = mix(a.xz, a.yw, f.y);
    return mix(a.x, a.y, f.z);
  }

  float sphere(vec3 p, vec4 spr) {
    return length(spr.xyz-p) - spr.w;
  }

  float flame(vec3 p) {
    float d = sphere(p, vec4(-0.460, -1.0, 0.0, 1.));
    return d + (noise(p + vec3(.0, 0. * 2., .0)) + noise(p * 3.) * .5) * .25 * (p.y);
  }

  void mainImage( out vec4 fragColor, in vec2 fragCoord, in vec2 size ) {
	// can we use z for p?
    vec4 p = 1.5 - vec4(flame(vec3(abs(fragCoord - vec2(0.5)), 0.)));
    // vec4 p = 1.5 - vec4(flame(vec3(abs(fragCoord - size * 0.5), 0.) / 500.0));

    float glow = p.w;
    vec4 col = mix(vec4(1., .5, .1, 1.), vec4(0.1, .5, 1., 1.), p.y * .02 + .4);
    fragColor = mix(vec4(0.), col, pow(glow * 0.75, 10.));
  }

  void main() {
    // mainImage(gl_FragColor, gl_FragCoord.xy, size);
    mainImage(gl_FragColor, gl_PointCoord, size);

	// gl_FragColor.r = 0.5;
	// gl_FragColor.a = max(gl_FragColor.a, 0.5);
	// gl_FragColor = vec4(1.0);
  }` };
}

/**
 * Get points geometry buffer for simulating flowing path.
 * @param {THREE.Vector3} point
 * @return {THREE.Geometry} point geometry
 * @member xglsl.pointGeom
 * @function
 */
export function pointGeom(point) {
	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		point
		// new THREE.Vector3( -10,  10, 0 )
		// new THREE.Vector3( -10, -10, 0 ),
		// new THREE.Vector3(  10, -10, 0 )
	);
	// geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );
	geometry.computeBoundingSphere();
	return geometry;
}

/**
 * Get shaders for creating color-morphable materail (THREE.Material).
 *
 * &lt;b>Note:&lt;/b>&lt;br>
 * As this shader doesn't provide face color difference, it is replaced by
 * {@link phongColorMorph}.
 * @param {object} paras
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.meshColors
 * @function
 */
function meshColors(vparas) {
	var colori = ''; // 'uniform vec4 u_color0; uniform float u_morph0;';
	var morph = 'vec3 morph = u_color0;';
	for (var i = 0; i &lt; vparas.colors.length; i++) {
		colori += `\nuniform vec3 u_color${i}; uniform float u_morph${i};`;
		if (i > 0)
			morph += `\nmorph = mix(morph, u_color${i}, u_morph${i - 1});`;
	}
	if (i > 0)
		morph += `\nmorph = mix(morph, u_color0, u_morph${i - 1});`;

	// debug notes - mixColor()
	//
    // working: return vec4(0.4, 0.5, 0.0, 0.7);
    // working: return vec4(mix(u_color0, u_color1, 0.1), 1);
    // working: return vec4(mix(u_color0, u_color1, u_morph0), 1);
	/* working:
    morph = mix(u_color0, u_color1, u_morph0);
    morph = mix(morph, u_color2, u_morph1);
    return vec4(morph, 1.0);
	*/
	return { vertexShader:
 `uniform float u_alpha;
  //uniform vec3 u_color0; uniform float u_morph0;
  ${colori}

  varying vec4 vColor;
  varying float vAlpha;

  vec4 mixColor() {
    ${morph}
    return vec4(morph, u_alpha);
  }

  void main() {
    vColor = mixColor();
    vAlpha = u_alpha;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
  }
 `,

		fragmentShader:
 // `void main() { gl_FragColor = vec4(1.0); } `
 `uniform sampler2D u_tex;
  varying vec4 vColor;
  varying float vAlpha;

  void main() {
    gl_FragColor = vColor;
    // gl_FragColor = gl_FragColor * texture2D( u_tex, gl_FragCoord );
    // gl_FragColor.a *= vAlpha;
  } `
 }
}

/**
 * Get shaders for creating color-morphable materail (THREE.Material).
 *
 * @param {object} paras
 * @return {object} {vertexShader, fragmentShader}
 * @member xglsl.phongColorMorph
 * @function
 */
function phongColorMorph(vparas) {
	var colori = ''; // 'uniform vec4 u_color0; uniform float u_morph0;';
	var morph = 'vec3 morph = u_color0;';
	for (var i = 0; i &lt; vparas.colors.length; i++) {
		colori += `\nuniform vec3 u_color${i}; uniform float u_morph${i};`;
		if (i > 0)
			morph += `\nmorph = mix(morph, u_color${i}, u_morph${i - 1});`;
	}
	if (i > 0)
		morph += `\nmorph = mix(morph, u_color0, u_morph${i - 1});`;

	// attribute vec3 position;
	// attribute vec3 normal;
	// uniform mat4 projection, modelview, normalMat;
	// uniform int mode;   // Rendering mode
	// uniform float Ka;   // Ambient reflection coefficient, e.g. 1.0,
	// uniform float Kd;   // Diffuse reflection coefficient, e.g. 0.4,
	// uniform float Ks;   // Specular reflection coefficient, e.g. 1.0,
	// Material color
	// uniform vec3 diffuseColor;
	var ka = '1.0';
	var kd = '1.0';
	var ks = '1.0';

	return { vertexShader:
  `	uniform float shininessVal; // Shininess, e.g. 80
	uniform vec3 ambientColor;
	uniform vec3 specularColor;
	uniform vec3 u_lightPos; // Light position
	uniform float u_alpha;

	${colori}

	varying vec3 normalInterp;
	varying vec3 vertPos;
	varying vec4 vColor; //color
	varying float vAlpha;

	vec3 morphColors() {
		${morph}
		return morph;
	}

	void main(){
		vAlpha = u_alpha;
		float Ka = ${ka};
		float Kd = ${kd};
		float Ks = ${ks};

		vec4 vertPos4 = modelViewMatrix * vec4(position, 1.0);
		vertPos = vec3(vertPos4) / vertPos4.w;
		// normalInterp = vec3(modelMatrix  * vec4(normal, 0.0));
		// normalInterp = vec3(normalMatrix * vec4(normal, 0.0)); // original
		   normalInterp = normalMatrix * normal; // three.js normalMatrix is 3 x 3
		gl_Position = projectionMatrix * vertPos4;

		vec3 N = normalize(normalInterp);
		vec3 L = normalize(u_lightPos - vertPos);

		// Lambert's cosine law
		float lambertian = max(dot(N, L), 0.0);
		float specular = 0.0;
		if(lambertian > 0.0) {
			vec3 R = reflect(-L, N);      // Reflected light vector
			vec3 V = normalize(-vertPos); // Vector to viewer
			// Compute the specular term
			float specAngle = max(dot(R, V), 0.0);
			specular = pow(specAngle, shininessVal);

			// debug
			// L = V;
			specular = pow(specAngle, 1.0);
		}

		vec3 diffuseColor = morphColors();

		vColor = vec4(Ka * ambientColor +
					Kd * lambertian * diffuseColor +
					Ks * specular * specularColor, u_alpha); // u_alpha = vparas.uniforms.u_alpha
		// working: vColor = vec4(L * Ka, 1.0);
		// working with normalMatrix: vColor = vec4(Kd * lambertian);
		// working with normalMatrix: vColor = vec4(Ks * specular, 0.1, 0.2, 1.0);
	}
  `,
	fragmentShader:
  `
	uniform sampler2D u_tex;
	varying vec4 vColor;
	varying float vAlpha;

	void main() {
		gl_FragColor = vColor;
		// gl_FragColor = gl_FragColor * texture2D( u_tex, gl_FragCoord );
		// gl_FragColor.a *= vAlpha;
	}
  `};
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">x-visual API</a></h2><h3>Classes</h3><ul><li><a href="AbsCluster.html">AbsCluster</a></li><li><a href="Affine.html">Affine</a></li><li><a href="AffineCombiner.html">AffineCombiner</a></li><li><a href="AssetKeepr.html">AssetKeepr</a></li><li><a href="Axisys.html">Axisys</a></li><li><a href="BaseComponent.html">BaseComponent</a></li><li><a href="CamCtrl.html">CamCtrl</a></li><li><a href="CanvTex.html">CanvTex</a></li><li><a href="ChannelFilter.html">ChannelFilter</a></li><li><a href="chart.html">chart</a></li><li><a href="chart.Axes.html">Axes</a></li><li><a href="chart.Bar.html">Bar</a></li><li><a href="chart.GridElem.html">GridElem</a></li><li><a href="chart.Pie.html">Pie</a></li><li><a href="chart.Sankey.html">Sankey</a></li><li><a href="CoordsGrid.html">CoordsGrid</a></li><li><a href="D3Pie.html">D3Pie</a></li><li><a href="ECS.html">ECS</a></li><li><a href="Entity.html">Entity</a></li><li><a href="FilmEffect.html">FilmEffect</a></li><li><a href="FinalComposer.html">FinalComposer</a></li><li><a href="GpuPicker.html">GpuPicker</a></li><li><a href="GridVisuals.html">GridVisuals</a></li><li><a href="Htmltex.html">Htmltex</a></li><li><a href="Hud.html">Hud</a></li><li><a href="Input.html">Input</a></li><li><a href="Layers.html">Layers</a></li><li><a href="Mapctrl.html">Mapctrl</a></li><li><a href="mat4.html">mat4</a></li><li><a href="MorphingAnim.html">MorphingAnim</a></li><li><a href="OSM3.html">OSM3</a></li><li><a href="OsmUtils.html">OsmUtils</a></li><li><a href="PathEffect.html">PathEffect</a></li><li><a href="pickuuid.html">pickuuid</a></li><li><a href="RayPicker.html">RayPicker</a></li><li><a href="rayuuid.html">rayuuid</a></li><li><a href="Request.html">Request</a></li><li><a href="System.html">System</a></li><li><a href="ThreeWrapper.html">ThreeWrapper</a></li><li><a href="Thrender.html">Thrender</a></li><li><a href="TilesKeeper.html">TilesKeeper</a></li><li><a href="Tween.html">Tween</a></li><li><a href="vec3.html">vec3</a></li><li><a href="Vec3_.html">Vec3</a></li><li><a href="global.html#x">x</a></li><li><a href="X_.html">X</a></li><li><a href="XComponent.html">XComponent</a></li><li><a href="XComponent.Canvas.html">Canvas</a></li><li><a href="XComponent.CmdFlag.html">CmdFlag</a></li><li><a href="XComponent.CmpTween.html">CmpTween</a></li><li><a href="XComponent.CmpTweens.html">CmpTweens</a></li><li><a href="XComponent.Dynatex.html">Dynatex</a></li><li><a href="XComponent.Filming.html">Filming</a></li><li><a href="XComponent.FlowingPath.html">FlowingPath</a></li><li><a href="XComponent.Glow.html">Glow</a></li><li><a href="XComponent.GlowingEdge.html">GlowingEdge</a></li><li><a href="XComponent.GpuPickable.html">GpuPickable</a></li><li><a href="XComponent.HudChild.html">HudChild</a></li><li><a href="XComponent.HudGroup.html">HudGroup</a></li><li><a href="XComponent.Input.html">Input</a></li><li><a href="XComponent.ModelSeqs.html">ModelSeqs</a></li><li><a href="XComponent.Obj3.html">Obj3</a></li><li><a href="XComponent.Occluder.html">Occluder</a></li><li><a href="XComponent.RayCastee.html">RayCastee</a></li><li><a href="XComponent.TweenScript.html">TweenScript</a></li><li><a href="XComponent.UserCmd.html">UserCmd</a></li><li><a href="XComponent.UserTween.html">UserTween</a></li><li><a href="XComponent.Visual.html">Visual</a></li><li><a href="XComponent.XCamera.html">XCamera</a></li><li><a href="XError.html">XError</a></li><li><a href="xgeom.html">xgeom</a></li><li><a href="xglsl.html">xglsl</a></li><li><a href="xmath.html">xmath</a></li><li><a href="XSankey.html">XSankey</a></li><li><a href="XSys.html">XSys</a></li><li><a href="XTweener.html">XTweener</a></li><li><a href="XTweenException.html">XTweenException</a></li><li><a href="xutils.html">xutils</a></li><li><a href="XWorld.html">XWorld</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AffineTrans">AffineTrans</a></li><li><a href="global.html#AffineType">AffineType</a></li><li><a href="global.html#browserVer">browserVer</a></li><li><a href="global.html#getEffectPass">getEffectPass</a></li><li><a href="global.html#interpret">interpret</a></li><li><a href="global.html#KeyFlag">KeyFlag</a></li><li><a href="global.html#LayerChannel">LayerChannel</a></li><li><a href="global.html#onMouse">onMouse</a></li><li><a href="global.html#R">R</a></li><li><a href="global.html#xcam">xcam</a></li><li><a href="global.html#XEasing">XEasing</a></li><li><a href="global.html#xecs">xecs</a></li><li><a href="global.html#xscene">xscene</a></li><li><a href="global.html#xview">xview</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed May 13 2020 16:42:05 GMT+0800 (Hong Kong Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
